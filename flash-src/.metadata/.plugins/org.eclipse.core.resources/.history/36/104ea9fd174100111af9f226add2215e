// Copyright (c) 2012 dozeo GmbH
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

package com.dozeo.pusheras
{
	import com.adobe.serialization.json.JSON;
	import com.adobe.serialization.json.JSONDecoder;
	import com.dozeo.pusheras.events.PusherEvent;
	import com.dozeo.pusheras.logger.WebSocketLogger;
	import com.dozeo.pusheras.utils.PusherConstants;
	import com.dozeo.pusheras.vo.PusherOptions;
	import com.dozeo.pusheras.vo.PusherStatus;
	import com.dozeo.pusheras.vo.WebsocketStatus;
	
	import flash.events.Event;
	import flash.events.EventDispatcher;
	
	import mx.charts.CategoryAxis;
	
	import net.gimite.websocket.IWebSocketLogger;
	import net.gimite.websocket.WebSocket;
	import net.gimite.websocket.WebSocketEvent;
	import net.gimite.websocket.WebSocketFrame;
	
	/**
	 * Pusher <http://pusher.com> ActionScript3 Client Library
	 * @author Tilman Griesel <https://github.com/TilmanGriesel> - dozeo GmbH <http://dozeo.com>
	 */
	public class Pusher extends EventDispatcher
	{
		// PusherAS vars
		private var _pusherOptions:PusherOptions;
		private var _pusherStatus:PusherStatus;
		
		// websocket vars
		private var _websocket:WebSocket;
		private var _websocketStatus:WebsocketStatus;

		/**
		 * @param options all required options for the pusher connection
		 * */
		public function Pusher(options:PusherOptions)
		{
			// parameter check
			if(options == null)
				throw new Error('options cannot be null');
			
			// store options
			_pusherOptions = options;
			
			// create small storage object for the websocket and pusher status
			_websocketStatus = new WebsocketStatus();
			_pusherStatus = new PusherStatus();
			
			this.addEventListener(PusherEvent.CONNECTION_ESTABLISHED, this_CONNECTION_ESTABLISHED);
		}
		
		public function connect():void
		{
			// connect to websocket server
			
			connectWebsocket();
		}
		
		/**
		 * inital websocket connection
		 * */
		private function connectWebsocket():void
		{
			// check for websocket status storage object
			if(_websocketStatus == null)
				throw new Error('websocket status cannot be null');

			// check for pusher status storage object
			if(_pusherStatus == null)
				throw new Error('pusher status cannot be null');
			
			// check if connection attempt is already in progress
			if(_websocketStatus.connecting)
			{
				log('Already attempting connection. Aborting...');
				return;
			}
			
			// check if websocket is already connected
			if(_websocketStatus.connected)
			{
				log('Connection is already established. Aborting connection attempt...');
				return;
			}
			
			// update status
			_pusherStatus.connecting = true;
			_websocketStatus.connecting = true;
			
			// get pusher url
			var pusherURL:String;
			if(_pusherOptions.encrypted || _pusherOptions.secure)
				pusherURL = _pusherOptions.pusherURL;
			else
				pusherURL = _pusherOptions.pusherSecureURL;
			
			// create websocket instance
			_websocket = new WebSocket(_websocketStatus.connectionIndex,
										pusherURL,
										_pusherOptions.protocols,
										_pusherOptions.origin,
										_pusherOptions.proxyHost,
										_pusherOptions.proxyPort,
										_pusherOptions.cookie,
										_pusherOptions.headers,
										new WebSocketLogger());
			
			// add websocket event listeners
			_websocket.addEventListener(WebSocketEvent.OPEN, _websocket_OPEN);
			_websocket.addEventListener(WebSocketEvent.CLOSE, _websocket_CLOSE);
			_websocket.addEventListener(WebSocketEvent.ERROR, _websocket_ERROR);
			_websocket.addEventListener(WebSocketEvent.MESSAGE, _websocket_MESSAGE);
			
		}
		
		protected function _websocket_OPEN(event:WebSocketEvent):void
		{
			log('_websocket_OPEN Event { Message:' + event.message + ' Code:' + event.code + ' Reason:' + event.reason + ' Clean:' + event.wasClean + ' }');
			
			// store status
			_websocketStatus.connected = true;
			
		}
		
		protected function _websocket_CLOSE(event:WebSocketEvent):void
		{
			log('_websocket_CLOSE Event { Message:' + event.message + ' Code:' + event.code + ' Reason:' + event.reason + ' Clean:' + event.wasClean + ' }');
			// TODO Auto-generated method stub
			
		}
		
		protected function _websocket_ERROR(event:WebSocketEvent):void
		{
			log('_websocket_ERROR Event { Message:' + event.message + ' Code:' + event.code + ' Reason:' + event.reason + ' Clean:' + event.wasClean + ' }');
			// TODO Auto-generated method stub
		}
		
		protected function _websocket_MESSAGE(event:WebSocketEvent):void
		{
			try
			{
				var pusherEvent:PusherEvent = PusherEvent.parse(event.message);				
			}
			catch(e:Error)
			{
				log('websocket message error: ' e.message);
				return;
			}
			
			this.dispatchEvent(pusherEvent);

			log('pusher event: ' + pusherEvent.toJSON());
		}
		
		protected function this_CONNECTION_ESTABLISHED(event:Event):void
		{
			log('this_CONNECTION_ESTABLISHED');
			_pusherStatus.connected = true;
			
		}
		
		private function log(msg:String):void
		{
			trace('LOG: ' + msg);
		}
		
		public function subscribe(channelName:String):void
		{
			// check the pusher connection
			if(_pusherStatus.connected == false)
				throw new Error('cannot subscribe "' + channelName + '" because the pusher service is not connected!');
			
			// create new pusher event
			var pusherEvent:PusherEvent = new PusherEvent(PusherEvent.SUBSCRIBE);
			pusherEvent.data.channel = channelName;
			
			dispatchPusherEvent(pusherEvent);
		}
	
		public function dispatchPusherEvent(event:PusherEvent):void
		{
			trace('dispatch: ' + event.type);
			// check websocket connection
			if(_websocketStatus.connected == false)
				throw new Error('websocket is not connected, cannot send event');
			
			try
			{
				trace('>>> dispatchign event');
				_websocket.send(event.toJSON());
			}
			catch(e:Error)
			{
				log('dispatchPusherEvent failed: ' + e.message);
			}
			
		}
		
	}
}